// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/main.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_Login_FullMethodName         = "/pb.UserService/Login"
	UserService_Logout_FullMethodName        = "/pb.UserService/Logout"
	UserService_GetAllUser_FullMethodName    = "/pb.UserService/GetAllUser"
	UserService_GetUserById_FullMethodName   = "/pb.UserService/GetUserById"
	UserService_CreateNewUser_FullMethodName = "/pb.UserService/CreateNewUser"
	UserService_UpdateUser_FullMethodName    = "/pb.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName    = "/pb.UserService/DeleteUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
	GetAllUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyUserResponse, error)
	GetUserById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*UserResponse, error)
	CreateNewUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserResponse, error)
	UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteUser(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, UserService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Logout(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, UserService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetAllUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyUserResponse)
	err := c.cc.Invoke(ctx, UserService_GetAllUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateNewUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateNewUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *NumbRequest) (*MessageResponse, error)
	GetAllUser(context.Context, *emptypb.Empty) (*ManyUserResponse, error)
	GetUserById(context.Context, *NumbRequest) (*UserResponse, error)
	CreateNewUser(context.Context, *User) (*UserResponse, error)
	UpdateUser(context.Context, *User) (*MessageResponse, error)
	DeleteUser(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServiceServer) Logout(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedUserServiceServer) GetAllUser(context.Context, *emptypb.Empty) (*ManyUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserById(context.Context, *NumbRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserServiceServer) CreateNewUser(context.Context, *User) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *User) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Logout(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetAllUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetAllUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetAllUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetAllUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateNewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateNewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateNewUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateNewUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _UserService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UserService_Logout_Handler,
		},
		{
			MethodName: "GetAllUser",
			Handler:    _UserService_GetAllUser_Handler,
		},
		{
			MethodName: "GetUserById",
			Handler:    _UserService_GetUserById_Handler,
		},
		{
			MethodName: "CreateNewUser",
			Handler:    _UserService_CreateNewUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	ConfigService_GetAllConfig_FullMethodName    = "/pb.ConfigService/GetAllConfig"
	ConfigService_GetConfigByKey_FullMethodName  = "/pb.ConfigService/GetConfigByKey"
	ConfigService_GetConfigById_FullMethodName   = "/pb.ConfigService/GetConfigById"
	ConfigService_CreateNewConfig_FullMethodName = "/pb.ConfigService/CreateNewConfig"
	ConfigService_UpdateConfig_FullMethodName    = "/pb.ConfigService/UpdateConfig"
	ConfigService_DeleteConfig_FullMethodName    = "/pb.ConfigService/DeleteConfig"
)

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	GetAllConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyConfigResponse, error)
	GetConfigByKey(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*ConfigResponse, error)
	GetConfigById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ConfigResponse, error)
	CreateNewConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*ConfigResponse, error)
	UpdateConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteConfig(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) GetAllConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_GetAllConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetConfigByKey(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*ConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_GetConfigByKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) GetConfigById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_GetConfigById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) CreateNewConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*ConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigResponse)
	err := c.cc.Invoke(ctx, ConfigService_CreateNewConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) UpdateConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ConfigService_UpdateConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) DeleteConfig(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ConfigService_DeleteConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations must embed UnimplementedConfigServiceServer
// for forward compatibility.
type ConfigServiceServer interface {
	GetAllConfig(context.Context, *emptypb.Empty) (*ManyConfigResponse, error)
	GetConfigByKey(context.Context, *MessageRequest) (*ConfigResponse, error)
	GetConfigById(context.Context, *NumbRequest) (*ConfigResponse, error)
	CreateNewConfig(context.Context, *Config) (*ConfigResponse, error)
	UpdateConfig(context.Context, *Config) (*MessageResponse, error)
	DeleteConfig(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedConfigServiceServer()
}

// UnimplementedConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConfigServiceServer struct{}

func (UnimplementedConfigServiceServer) GetAllConfig(context.Context, *emptypb.Empty) (*ManyConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllConfig not implemented")
}
func (UnimplementedConfigServiceServer) GetConfigByKey(context.Context, *MessageRequest) (*ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigByKey not implemented")
}
func (UnimplementedConfigServiceServer) GetConfigById(context.Context, *NumbRequest) (*ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigById not implemented")
}
func (UnimplementedConfigServiceServer) CreateNewConfig(context.Context, *Config) (*ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewConfig not implemented")
}
func (UnimplementedConfigServiceServer) UpdateConfig(context.Context, *Config) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfig not implemented")
}
func (UnimplementedConfigServiceServer) DeleteConfig(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConfig not implemented")
}
func (UnimplementedConfigServiceServer) mustEmbedUnimplementedConfigServiceServer() {}
func (UnimplementedConfigServiceServer) testEmbeddedByValue()                       {}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	// If the following call pancis, it indicates UnimplementedConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConfigService_ServiceDesc, srv)
}

func _ConfigService_GetAllConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetAllConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetAllConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetAllConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_GetConfigByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetConfigByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetConfigByKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetConfigByKey(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_GetConfigById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).GetConfigById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_GetConfigById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).GetConfigById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_CreateNewConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).CreateNewConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_CreateNewConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).CreateNewConfig(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_UpdateConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).UpdateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_UpdateConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).UpdateConfig(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_DeleteConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).DeleteConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigService_DeleteConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).DeleteConfig(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigService_ServiceDesc is the grpc.ServiceDesc for ConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllConfig",
			Handler:    _ConfigService_GetAllConfig_Handler,
		},
		{
			MethodName: "GetConfigByKey",
			Handler:    _ConfigService_GetConfigByKey_Handler,
		},
		{
			MethodName: "GetConfigById",
			Handler:    _ConfigService_GetConfigById_Handler,
		},
		{
			MethodName: "CreateNewConfig",
			Handler:    _ConfigService_CreateNewConfig_Handler,
		},
		{
			MethodName: "UpdateConfig",
			Handler:    _ConfigService_UpdateConfig_Handler,
		},
		{
			MethodName: "DeleteConfig",
			Handler:    _ConfigService_DeleteConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	ComponentService_GetAllComponent_FullMethodName        = "/pb.ComponentService/GetAllComponent"
	ComponentService_GetComponentById_FullMethodName       = "/pb.ComponentService/GetComponentById"
	ComponentService_GetComponentByName_FullMethodName     = "/pb.ComponentService/GetComponentByName"
	ComponentService_GetComponentByPosition_FullMethodName = "/pb.ComponentService/GetComponentByPosition"
	ComponentService_CreateNewComponent_FullMethodName     = "/pb.ComponentService/CreateNewComponent"
	ComponentService_UpdateComponent_FullMethodName        = "/pb.ComponentService/UpdateComponent"
	ComponentService_DeleteComponent_FullMethodName        = "/pb.ComponentService/DeleteComponent"
)

// ComponentServiceClient is the client API for ComponentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ComponentServiceClient interface {
	GetAllComponent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyComponentResponse, error)
	GetComponentById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ComponentResponse, error)
	GetComponentByName(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*ComponentResponse, error)
	GetComponentByPosition(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyComponentResponse, error)
	CreateNewComponent(ctx context.Context, in *Component, opts ...grpc.CallOption) (*ComponentResponse, error)
	UpdateComponent(ctx context.Context, in *Component, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteComponent(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type componentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewComponentServiceClient(cc grpc.ClientConnInterface) ComponentServiceClient {
	return &componentServiceClient{cc}
}

func (c *componentServiceClient) GetAllComponent(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyComponentResponse)
	err := c.cc.Invoke(ctx, ComponentService_GetAllComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) GetComponentById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComponentResponse)
	err := c.cc.Invoke(ctx, ComponentService_GetComponentById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) GetComponentByName(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*ComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComponentResponse)
	err := c.cc.Invoke(ctx, ComponentService_GetComponentByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) GetComponentByPosition(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyComponentResponse)
	err := c.cc.Invoke(ctx, ComponentService_GetComponentByPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) CreateNewComponent(ctx context.Context, in *Component, opts ...grpc.CallOption) (*ComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComponentResponse)
	err := c.cc.Invoke(ctx, ComponentService_CreateNewComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) UpdateComponent(ctx context.Context, in *Component, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ComponentService_UpdateComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *componentServiceClient) DeleteComponent(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ComponentService_DeleteComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ComponentServiceServer is the server API for ComponentService service.
// All implementations must embed UnimplementedComponentServiceServer
// for forward compatibility.
type ComponentServiceServer interface {
	GetAllComponent(context.Context, *emptypb.Empty) (*ManyComponentResponse, error)
	GetComponentById(context.Context, *NumbRequest) (*ComponentResponse, error)
	GetComponentByName(context.Context, *MessageRequest) (*ComponentResponse, error)
	GetComponentByPosition(context.Context, *NumbRequest) (*ManyComponentResponse, error)
	CreateNewComponent(context.Context, *Component) (*ComponentResponse, error)
	UpdateComponent(context.Context, *Component) (*MessageResponse, error)
	DeleteComponent(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedComponentServiceServer()
}

// UnimplementedComponentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedComponentServiceServer struct{}

func (UnimplementedComponentServiceServer) GetAllComponent(context.Context, *emptypb.Empty) (*ManyComponentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllComponent not implemented")
}
func (UnimplementedComponentServiceServer) GetComponentById(context.Context, *NumbRequest) (*ComponentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComponentById not implemented")
}
func (UnimplementedComponentServiceServer) GetComponentByName(context.Context, *MessageRequest) (*ComponentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComponentByName not implemented")
}
func (UnimplementedComponentServiceServer) GetComponentByPosition(context.Context, *NumbRequest) (*ManyComponentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComponentByPosition not implemented")
}
func (UnimplementedComponentServiceServer) CreateNewComponent(context.Context, *Component) (*ComponentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewComponent not implemented")
}
func (UnimplementedComponentServiceServer) UpdateComponent(context.Context, *Component) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateComponent not implemented")
}
func (UnimplementedComponentServiceServer) DeleteComponent(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComponent not implemented")
}
func (UnimplementedComponentServiceServer) mustEmbedUnimplementedComponentServiceServer() {}
func (UnimplementedComponentServiceServer) testEmbeddedByValue()                          {}

// UnsafeComponentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ComponentServiceServer will
// result in compilation errors.
type UnsafeComponentServiceServer interface {
	mustEmbedUnimplementedComponentServiceServer()
}

func RegisterComponentServiceServer(s grpc.ServiceRegistrar, srv ComponentServiceServer) {
	// If the following call pancis, it indicates UnimplementedComponentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ComponentService_ServiceDesc, srv)
}

func _ComponentService_GetAllComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).GetAllComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_GetAllComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).GetAllComponent(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_GetComponentById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).GetComponentById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_GetComponentById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).GetComponentById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_GetComponentByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).GetComponentByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_GetComponentByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).GetComponentByName(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_GetComponentByPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).GetComponentByPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_GetComponentByPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).GetComponentByPosition(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_CreateNewComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Component)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).CreateNewComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_CreateNewComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).CreateNewComponent(ctx, req.(*Component))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_UpdateComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Component)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).UpdateComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_UpdateComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).UpdateComponent(ctx, req.(*Component))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComponentService_DeleteComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComponentServiceServer).DeleteComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ComponentService_DeleteComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComponentServiceServer).DeleteComponent(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ComponentService_ServiceDesc is the grpc.ServiceDesc for ComponentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ComponentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ComponentService",
	HandlerType: (*ComponentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllComponent",
			Handler:    _ComponentService_GetAllComponent_Handler,
		},
		{
			MethodName: "GetComponentById",
			Handler:    _ComponentService_GetComponentById_Handler,
		},
		{
			MethodName: "GetComponentByName",
			Handler:    _ComponentService_GetComponentByName_Handler,
		},
		{
			MethodName: "GetComponentByPosition",
			Handler:    _ComponentService_GetComponentByPosition_Handler,
		},
		{
			MethodName: "CreateNewComponent",
			Handler:    _ComponentService_CreateNewComponent_Handler,
		},
		{
			MethodName: "UpdateComponent",
			Handler:    _ComponentService_UpdateComponent_Handler,
		},
		{
			MethodName: "DeleteComponent",
			Handler:    _ComponentService_DeleteComponent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	AuthService_GetAuthByUserId_FullMethodName = "/pb.AuthService/GetAuthByUserId"
	AuthService_CheckAuth_FullMethodName       = "/pb.AuthService/CheckAuth"
	AuthService_RefreshToken_FullMethodName    = "/pb.AuthService/RefreshToken"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	GetAuthByUserId(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	CheckAuth(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	RefreshToken(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) GetAuthByUserId(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, AuthService_GetAuthByUserId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CheckAuth(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, AuthService_CheckAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	GetAuthByUserId(context.Context, *NumbRequest) (*AuthResponse, error)
	CheckAuth(context.Context, *MessageRequest) (*AuthResponse, error)
	RefreshToken(context.Context, *MessageRequest) (*LoginResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) GetAuthByUserId(context.Context, *NumbRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthByUserId not implemented")
}
func (UnimplementedAuthServiceServer) CheckAuth(context.Context, *MessageRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAuth not implemented")
}
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *MessageRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_GetAuthByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAuthByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetAuthByUserId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAuthByUserId(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CheckAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CheckAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_CheckAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CheckAuth(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RefreshToken(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthByUserId",
			Handler:    _AuthService_GetAuthByUserId_Handler,
		},
		{
			MethodName: "CheckAuth",
			Handler:    _AuthService_CheckAuth_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthService_RefreshToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	ImageService_GetAllImage_FullMethodName    = "/pb.ImageService/GetAllImage"
	ImageService_GetImageById_FullMethodName   = "/pb.ImageService/GetImageById"
	ImageService_CreateNewImage_FullMethodName = "/pb.ImageService/CreateNewImage"
	ImageService_UpdateImage_FullMethodName    = "/pb.ImageService/UpdateImage"
	ImageService_DeleteImage_FullMethodName    = "/pb.ImageService/DeleteImage"
)

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImageServiceClient interface {
	GetAllImage(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyImageResponse, error)
	GetImageById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ImageResponse, error)
	CreateNewImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*ImageResponse, error)
	UpdateImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteImage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type imageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) GetAllImage(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyImageResponse)
	err := c.cc.Invoke(ctx, ImageService_GetAllImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) GetImageById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageResponse)
	err := c.cc.Invoke(ctx, ImageService_GetImageById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) CreateNewImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*ImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageResponse)
	err := c.cc.Invoke(ctx, ImageService_CreateNewImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) UpdateImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ImageService_UpdateImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) DeleteImage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, ImageService_DeleteImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
// All implementations must embed UnimplementedImageServiceServer
// for forward compatibility.
type ImageServiceServer interface {
	GetAllImage(context.Context, *emptypb.Empty) (*ManyImageResponse, error)
	GetImageById(context.Context, *NumbRequest) (*ImageResponse, error)
	CreateNewImage(context.Context, *Image) (*ImageResponse, error)
	UpdateImage(context.Context, *Image) (*MessageResponse, error)
	DeleteImage(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedImageServiceServer()
}

// UnimplementedImageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageServiceServer struct{}

func (UnimplementedImageServiceServer) GetAllImage(context.Context, *emptypb.Empty) (*ManyImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllImage not implemented")
}
func (UnimplementedImageServiceServer) GetImageById(context.Context, *NumbRequest) (*ImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageById not implemented")
}
func (UnimplementedImageServiceServer) CreateNewImage(context.Context, *Image) (*ImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewImage not implemented")
}
func (UnimplementedImageServiceServer) UpdateImage(context.Context, *Image) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateImage not implemented")
}
func (UnimplementedImageServiceServer) DeleteImage(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedImageServiceServer) mustEmbedUnimplementedImageServiceServer() {}
func (UnimplementedImageServiceServer) testEmbeddedByValue()                      {}

// UnsafeImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageServiceServer will
// result in compilation errors.
type UnsafeImageServiceServer interface {
	mustEmbedUnimplementedImageServiceServer()
}

func RegisterImageServiceServer(s grpc.ServiceRegistrar, srv ImageServiceServer) {
	// If the following call pancis, it indicates UnimplementedImageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImageService_ServiceDesc, srv)
}

func _ImageService_GetAllImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).GetAllImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_GetAllImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).GetAllImage(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_GetImageById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).GetImageById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_GetImageById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).GetImageById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_CreateNewImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Image)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).CreateNewImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_CreateNewImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).CreateNewImage(ctx, req.(*Image))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_UpdateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Image)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).UpdateImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_UpdateImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).UpdateImage(ctx, req.(*Image))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_DeleteImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).DeleteImage(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageService_ServiceDesc is the grpc.ServiceDesc for ImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllImage",
			Handler:    _ImageService_GetAllImage_Handler,
		},
		{
			MethodName: "GetImageById",
			Handler:    _ImageService_GetImageById_Handler,
		},
		{
			MethodName: "CreateNewImage",
			Handler:    _ImageService_CreateNewImage_Handler,
		},
		{
			MethodName: "UpdateImage",
			Handler:    _ImageService_UpdateImage_Handler,
		},
		{
			MethodName: "DeleteImage",
			Handler:    _ImageService_DeleteImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	MenuService_GetAllMenu_FullMethodName    = "/pb.MenuService/GetAllMenu"
	MenuService_GetMenuById_FullMethodName   = "/pb.MenuService/GetMenuById"
	MenuService_CreateNewMenu_FullMethodName = "/pb.MenuService/CreateNewMenu"
	MenuService_UpdateMenu_FullMethodName    = "/pb.MenuService/UpdateMenu"
	MenuService_DeleteMenu_FullMethodName    = "/pb.MenuService/DeleteMenu"
)

// MenuServiceClient is the client API for MenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuServiceClient interface {
	GetAllMenu(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyMenuResponse, error)
	GetMenuById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MenuResponse, error)
	CreateNewMenu(ctx context.Context, in *Menu, opts ...grpc.CallOption) (*MenuResponse, error)
	UpdateMenu(ctx context.Context, in *Menu, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteMenu(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type menuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuServiceClient(cc grpc.ClientConnInterface) MenuServiceClient {
	return &menuServiceClient{cc}
}

func (c *menuServiceClient) GetAllMenu(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyMenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyMenuResponse)
	err := c.cc.Invoke(ctx, MenuService_GetAllMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) GetMenuById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuResponse)
	err := c.cc.Invoke(ctx, MenuService_GetMenuById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) CreateNewMenu(ctx context.Context, in *Menu, opts ...grpc.CallOption) (*MenuResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuResponse)
	err := c.cc.Invoke(ctx, MenuService_CreateNewMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) UpdateMenu(ctx context.Context, in *Menu, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, MenuService_UpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) DeleteMenu(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, MenuService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServiceServer is the server API for MenuService service.
// All implementations must embed UnimplementedMenuServiceServer
// for forward compatibility.
type MenuServiceServer interface {
	GetAllMenu(context.Context, *emptypb.Empty) (*ManyMenuResponse, error)
	GetMenuById(context.Context, *NumbRequest) (*MenuResponse, error)
	CreateNewMenu(context.Context, *Menu) (*MenuResponse, error)
	UpdateMenu(context.Context, *Menu) (*MessageResponse, error)
	DeleteMenu(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedMenuServiceServer()
}

// UnimplementedMenuServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuServiceServer struct{}

func (UnimplementedMenuServiceServer) GetAllMenu(context.Context, *emptypb.Empty) (*ManyMenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllMenu not implemented")
}
func (UnimplementedMenuServiceServer) GetMenuById(context.Context, *NumbRequest) (*MenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuById not implemented")
}
func (UnimplementedMenuServiceServer) CreateNewMenu(context.Context, *Menu) (*MenuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewMenu not implemented")
}
func (UnimplementedMenuServiceServer) UpdateMenu(context.Context, *Menu) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServiceServer) DeleteMenu(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServiceServer) mustEmbedUnimplementedMenuServiceServer() {}
func (UnimplementedMenuServiceServer) testEmbeddedByValue()                     {}

// UnsafeMenuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServiceServer will
// result in compilation errors.
type UnsafeMenuServiceServer interface {
	mustEmbedUnimplementedMenuServiceServer()
}

func RegisterMenuServiceServer(s grpc.ServiceRegistrar, srv MenuServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuService_ServiceDesc, srv)
}

func _MenuService_GetAllMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetAllMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetAllMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetAllMenu(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_GetMenuById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetMenuById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetMenuById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetMenuById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_CreateNewMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Menu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).CreateNewMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_CreateNewMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).CreateNewMenu(ctx, req.(*Menu))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Menu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_UpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).UpdateMenu(ctx, req.(*Menu))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).DeleteMenu(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuService_ServiceDesc is the grpc.ServiceDesc for MenuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MenuService",
	HandlerType: (*MenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllMenu",
			Handler:    _MenuService_GetAllMenu_Handler,
		},
		{
			MethodName: "GetMenuById",
			Handler:    _MenuService_GetMenuById_Handler,
		},
		{
			MethodName: "CreateNewMenu",
			Handler:    _MenuService_CreateNewMenu_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _MenuService_UpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _MenuService_DeleteMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	MenuLocationService_GetAllLocation_FullMethodName      = "/pb.MenuLocationService/GetAllLocation"
	MenuLocationService_GetLocationById_FullMethodName     = "/pb.MenuLocationService/GetLocationById"
	MenuLocationService_GetLocationByMenuId_FullMethodName = "/pb.MenuLocationService/GetLocationByMenuId"
	MenuLocationService_UpdateMenuLocation_FullMethodName  = "/pb.MenuLocationService/UpdateMenuLocation"
)

// MenuLocationServiceClient is the client API for MenuLocationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuLocationServiceClient interface {
	GetAllLocation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyMenuLocationResponse, error)
	GetLocationById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MenuLocationResponse, error)
	GetLocationByMenuId(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyMenuLocationResponse, error)
	UpdateMenuLocation(ctx context.Context, in *MenuLocation, opts ...grpc.CallOption) (*MessageResponse, error)
}

type menuLocationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuLocationServiceClient(cc grpc.ClientConnInterface) MenuLocationServiceClient {
	return &menuLocationServiceClient{cc}
}

func (c *menuLocationServiceClient) GetAllLocation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyMenuLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyMenuLocationResponse)
	err := c.cc.Invoke(ctx, MenuLocationService_GetAllLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuLocationServiceClient) GetLocationById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MenuLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuLocationResponse)
	err := c.cc.Invoke(ctx, MenuLocationService_GetLocationById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuLocationServiceClient) GetLocationByMenuId(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyMenuLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyMenuLocationResponse)
	err := c.cc.Invoke(ctx, MenuLocationService_GetLocationByMenuId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuLocationServiceClient) UpdateMenuLocation(ctx context.Context, in *MenuLocation, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, MenuLocationService_UpdateMenuLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuLocationServiceServer is the server API for MenuLocationService service.
// All implementations must embed UnimplementedMenuLocationServiceServer
// for forward compatibility.
type MenuLocationServiceServer interface {
	GetAllLocation(context.Context, *emptypb.Empty) (*ManyMenuLocationResponse, error)
	GetLocationById(context.Context, *NumbRequest) (*MenuLocationResponse, error)
	GetLocationByMenuId(context.Context, *NumbRequest) (*ManyMenuLocationResponse, error)
	UpdateMenuLocation(context.Context, *MenuLocation) (*MessageResponse, error)
	mustEmbedUnimplementedMenuLocationServiceServer()
}

// UnimplementedMenuLocationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMenuLocationServiceServer struct{}

func (UnimplementedMenuLocationServiceServer) GetAllLocation(context.Context, *emptypb.Empty) (*ManyMenuLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllLocation not implemented")
}
func (UnimplementedMenuLocationServiceServer) GetLocationById(context.Context, *NumbRequest) (*MenuLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationById not implemented")
}
func (UnimplementedMenuLocationServiceServer) GetLocationByMenuId(context.Context, *NumbRequest) (*ManyMenuLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocationByMenuId not implemented")
}
func (UnimplementedMenuLocationServiceServer) UpdateMenuLocation(context.Context, *MenuLocation) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenuLocation not implemented")
}
func (UnimplementedMenuLocationServiceServer) mustEmbedUnimplementedMenuLocationServiceServer() {}
func (UnimplementedMenuLocationServiceServer) testEmbeddedByValue()                             {}

// UnsafeMenuLocationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuLocationServiceServer will
// result in compilation errors.
type UnsafeMenuLocationServiceServer interface {
	mustEmbedUnimplementedMenuLocationServiceServer()
}

func RegisterMenuLocationServiceServer(s grpc.ServiceRegistrar, srv MenuLocationServiceServer) {
	// If the following call pancis, it indicates UnimplementedMenuLocationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MenuLocationService_ServiceDesc, srv)
}

func _MenuLocationService_GetAllLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuLocationServiceServer).GetAllLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuLocationService_GetAllLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuLocationServiceServer).GetAllLocation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuLocationService_GetLocationById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuLocationServiceServer).GetLocationById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuLocationService_GetLocationById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuLocationServiceServer).GetLocationById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuLocationService_GetLocationByMenuId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuLocationServiceServer).GetLocationByMenuId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuLocationService_GetLocationByMenuId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuLocationServiceServer).GetLocationByMenuId(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuLocationService_UpdateMenuLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuLocation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuLocationServiceServer).UpdateMenuLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuLocationService_UpdateMenuLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuLocationServiceServer).UpdateMenuLocation(ctx, req.(*MenuLocation))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuLocationService_ServiceDesc is the grpc.ServiceDesc for MenuLocationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuLocationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.MenuLocationService",
	HandlerType: (*MenuLocationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllLocation",
			Handler:    _MenuLocationService_GetAllLocation_Handler,
		},
		{
			MethodName: "GetLocationById",
			Handler:    _MenuLocationService_GetLocationById_Handler,
		},
		{
			MethodName: "GetLocationByMenuId",
			Handler:    _MenuLocationService_GetLocationByMenuId_Handler,
		},
		{
			MethodName: "UpdateMenuLocation",
			Handler:    _MenuLocationService_UpdateMenuLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	CategoryService_GetAllCategory_FullMethodName           = "/pb.CategoryService/GetAllCategory"
	CategoryService_GetCategoryById_FullMethodName          = "/pb.CategoryService/GetCategoryById"
	CategoryService_GetCategoryByManyId_FullMethodName      = "/pb.CategoryService/GetCategoryByManyId"
	CategoryService_GetCategoryBySlug_FullMethodName        = "/pb.CategoryService/GetCategoryBySlug"
	CategoryService_GetCategoryByType_FullMethodName        = "/pb.CategoryService/GetCategoryByType"
	CategoryService_GetCategoryByParent_FullMethodName      = "/pb.CategoryService/GetCategoryByParent"
	CategoryService_GetCategoryByTypeNParent_FullMethodName = "/pb.CategoryService/GetCategoryByTypeNParent"
	CategoryService_CreateNewCategory_FullMethodName        = "/pb.CategoryService/CreateNewCategory"
	CategoryService_UpdateCategory_FullMethodName           = "/pb.CategoryService/UpdateCategory"
	CategoryService_DeleteCategory_FullMethodName           = "/pb.CategoryService/DeleteCategory"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryServiceClient interface {
	GetAllCategory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyCategoryResponse, error)
	GetCategoryById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*CategoryResponse, error)
	GetCategoryByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error)
	GetCategoryBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*CategoryResponse, error)
	GetCategoryByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error)
	GetCategoryByParent(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error)
	GetCategoryByTypeNParent(ctx context.Context, in *Category, opts ...grpc.CallOption) (*ManyCategoryResponse, error)
	CreateNewCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryResponse, error)
	UpdateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteCategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) GetAllCategory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetAllCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*CategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryByManyId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*CategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryBySlug_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryByParent(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryByParent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryByTypeNParent(ctx context.Context, in *Category, opts ...grpc.CallOption) (*ManyCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryByTypeNParent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) CreateNewCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*CategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_CreateNewCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) UpdateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, CategoryService_UpdateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, CategoryService_DeleteCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility.
type CategoryServiceServer interface {
	GetAllCategory(context.Context, *emptypb.Empty) (*ManyCategoryResponse, error)
	GetCategoryById(context.Context, *NumbRequest) (*CategoryResponse, error)
	GetCategoryByManyId(context.Context, *ManyNumbRequest) (*ManyCategoryResponse, error)
	GetCategoryBySlug(context.Context, *MessageRequest) (*CategoryResponse, error)
	GetCategoryByType(context.Context, *NumbRequest) (*ManyCategoryResponse, error)
	GetCategoryByParent(context.Context, *NumbRequest) (*ManyCategoryResponse, error)
	GetCategoryByTypeNParent(context.Context, *Category) (*ManyCategoryResponse, error)
	CreateNewCategory(context.Context, *Category) (*CategoryResponse, error)
	UpdateCategory(context.Context, *Category) (*MessageResponse, error)
	DeleteCategory(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) GetAllCategory(context.Context, *emptypb.Empty) (*ManyCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryById(context.Context, *NumbRequest) (*CategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryById not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryByManyId(context.Context, *ManyNumbRequest) (*ManyCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryByManyId not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryBySlug(context.Context, *MessageRequest) (*CategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryBySlug not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryByType(context.Context, *NumbRequest) (*ManyCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryByType not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryByParent(context.Context, *NumbRequest) (*ManyCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryByParent not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryByTypeNParent(context.Context, *Category) (*ManyCategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryByTypeNParent not implemented")
}
func (UnimplementedCategoryServiceServer) CreateNewCategory(context.Context, *Category) (*CategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewCategory not implemented")
}
func (UnimplementedCategoryServiceServer) UpdateCategory(context.Context, *Category) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue()                         {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_GetAllCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetAllCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetAllCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetAllCategory(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryByManyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManyNumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryByManyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryByManyId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryByManyId(ctx, req.(*ManyNumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryBySlug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryBySlug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryBySlug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryBySlug(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryByType(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryByParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryByParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryByParent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryByParent(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryByTypeNParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryByTypeNParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryByTypeNParent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryByTypeNParent(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_CreateNewCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).CreateNewCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_CreateNewCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).CreateNewCategory(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_UpdateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_UpdateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).UpdateCategory(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_DeleteCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllCategory",
			Handler:    _CategoryService_GetAllCategory_Handler,
		},
		{
			MethodName: "GetCategoryById",
			Handler:    _CategoryService_GetCategoryById_Handler,
		},
		{
			MethodName: "GetCategoryByManyId",
			Handler:    _CategoryService_GetCategoryByManyId_Handler,
		},
		{
			MethodName: "GetCategoryBySlug",
			Handler:    _CategoryService_GetCategoryBySlug_Handler,
		},
		{
			MethodName: "GetCategoryByType",
			Handler:    _CategoryService_GetCategoryByType_Handler,
		},
		{
			MethodName: "GetCategoryByParent",
			Handler:    _CategoryService_GetCategoryByParent_Handler,
		},
		{
			MethodName: "GetCategoryByTypeNParent",
			Handler:    _CategoryService_GetCategoryByTypeNParent_Handler,
		},
		{
			MethodName: "CreateNewCategory",
			Handler:    _CategoryService_CreateNewCategory_Handler,
		},
		{
			MethodName: "UpdateCategory",
			Handler:    _CategoryService_UpdateCategory_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _CategoryService_DeleteCategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	PageService_GetAllPage_FullMethodName                   = "/pb.PageService/GetAllPage"
	PageService_GetPageById_FullMethodName                  = "/pb.PageService/GetPageById"
	PageService_GetPageByManyId_FullMethodName              = "/pb.PageService/GetPageByManyId"
	PageService_GetPageBySlug_FullMethodName                = "/pb.PageService/GetPageBySlug"
	PageService_GetPageByStatus_FullMethodName              = "/pb.PageService/GetPageByStatus"
	PageService_GetPageByUser_FullMethodName                = "/pb.PageService/GetPageByUser"
	PageService_GetPageByType_FullMethodName                = "/pb.PageService/GetPageByType"
	PageService_GetPageByTypeNStatus_FullMethodName         = "/pb.PageService/GetPageByTypeNStatus"
	PageService_GetPageByPublishYear_FullMethodName         = "/pb.PageService/GetPageByPublishYear"
	PageService_GetPageByPublishYearMonth_FullMethodName    = "/pb.PageService/GetPageByPublishYearMonth"
	PageService_GetPageByPublishYearMonthDay_FullMethodName = "/pb.PageService/GetPageByPublishYearMonthDay"
	PageService_CreateNewPage_FullMethodName                = "/pb.PageService/CreateNewPage"
	PageService_UpdatePage_FullMethodName                   = "/pb.PageService/UpdatePage"
	PageService_DeletePage_FullMethodName                   = "/pb.PageService/DeletePage"
	PageService_CountPageByType_FullMethodName              = "/pb.PageService/CountPageByType"
	PageService_CountPageByTypeNStatus_FullMethodName       = "/pb.PageService/CountPageByTypeNStatus"
)

// PageServiceClient is the client API for PageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PageServiceClient interface {
	GetAllPage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*PageResponse, error)
	GetPageByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*PageResponse, error)
	GetPageByStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByUser(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByType(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByTypeNStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByPublishYear(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByPublishYearMonth(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	GetPageByPublishYearMonthDay(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error)
	CreateNewPage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*PageResponse, error)
	UpdatePage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*MessageResponse, error)
	DeletePage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
	CountPageByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*NumbResponse, error)
	CountPageByTypeNStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*NumbResponse, error)
}

type pageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPageServiceClient(cc grpc.ClientConnInterface) PageServiceClient {
	return &pageServiceClient{cc}
}

func (c *pageServiceClient) GetAllPage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetAllPage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*PageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByManyId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*PageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageBySlug_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByUser(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByType(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByTypeNStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByTypeNStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByPublishYear(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByPublishYear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByPublishYearMonth(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByPublishYearMonth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) GetPageByPublishYearMonthDay(ctx context.Context, in *Page, opts ...grpc.CallOption) (*ManyPageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPageResponse)
	err := c.cc.Invoke(ctx, PageService_GetPageByPublishYearMonthDay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) CreateNewPage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*PageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PageResponse)
	err := c.cc.Invoke(ctx, PageService_CreateNewPage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) UpdatePage(ctx context.Context, in *Page, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, PageService_UpdatePage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) DeletePage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, PageService_DeletePage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) CountPageByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*NumbResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NumbResponse)
	err := c.cc.Invoke(ctx, PageService_CountPageByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pageServiceClient) CountPageByTypeNStatus(ctx context.Context, in *Page, opts ...grpc.CallOption) (*NumbResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NumbResponse)
	err := c.cc.Invoke(ctx, PageService_CountPageByTypeNStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PageServiceServer is the server API for PageService service.
// All implementations must embed UnimplementedPageServiceServer
// for forward compatibility.
type PageServiceServer interface {
	GetAllPage(context.Context, *Page) (*ManyPageResponse, error)
	GetPageById(context.Context, *NumbRequest) (*PageResponse, error)
	GetPageByManyId(context.Context, *ManyNumbRequest) (*ManyPageResponse, error)
	GetPageBySlug(context.Context, *MessageRequest) (*PageResponse, error)
	GetPageByStatus(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByUser(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByType(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByTypeNStatus(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByPublishYear(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByPublishYearMonth(context.Context, *Page) (*ManyPageResponse, error)
	GetPageByPublishYearMonthDay(context.Context, *Page) (*ManyPageResponse, error)
	CreateNewPage(context.Context, *Page) (*PageResponse, error)
	UpdatePage(context.Context, *Page) (*MessageResponse, error)
	DeletePage(context.Context, *NumbRequest) (*MessageResponse, error)
	CountPageByType(context.Context, *NumbRequest) (*NumbResponse, error)
	CountPageByTypeNStatus(context.Context, *Page) (*NumbResponse, error)
	mustEmbedUnimplementedPageServiceServer()
}

// UnimplementedPageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPageServiceServer struct{}

func (UnimplementedPageServiceServer) GetAllPage(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPage not implemented")
}
func (UnimplementedPageServiceServer) GetPageById(context.Context, *NumbRequest) (*PageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageById not implemented")
}
func (UnimplementedPageServiceServer) GetPageByManyId(context.Context, *ManyNumbRequest) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByManyId not implemented")
}
func (UnimplementedPageServiceServer) GetPageBySlug(context.Context, *MessageRequest) (*PageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageBySlug not implemented")
}
func (UnimplementedPageServiceServer) GetPageByStatus(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByStatus not implemented")
}
func (UnimplementedPageServiceServer) GetPageByUser(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByUser not implemented")
}
func (UnimplementedPageServiceServer) GetPageByType(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByType not implemented")
}
func (UnimplementedPageServiceServer) GetPageByTypeNStatus(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByTypeNStatus not implemented")
}
func (UnimplementedPageServiceServer) GetPageByPublishYear(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByPublishYear not implemented")
}
func (UnimplementedPageServiceServer) GetPageByPublishYearMonth(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByPublishYearMonth not implemented")
}
func (UnimplementedPageServiceServer) GetPageByPublishYearMonthDay(context.Context, *Page) (*ManyPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPageByPublishYearMonthDay not implemented")
}
func (UnimplementedPageServiceServer) CreateNewPage(context.Context, *Page) (*PageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewPage not implemented")
}
func (UnimplementedPageServiceServer) UpdatePage(context.Context, *Page) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePage not implemented")
}
func (UnimplementedPageServiceServer) DeletePage(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePage not implemented")
}
func (UnimplementedPageServiceServer) CountPageByType(context.Context, *NumbRequest) (*NumbResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountPageByType not implemented")
}
func (UnimplementedPageServiceServer) CountPageByTypeNStatus(context.Context, *Page) (*NumbResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountPageByTypeNStatus not implemented")
}
func (UnimplementedPageServiceServer) mustEmbedUnimplementedPageServiceServer() {}
func (UnimplementedPageServiceServer) testEmbeddedByValue()                     {}

// UnsafePageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PageServiceServer will
// result in compilation errors.
type UnsafePageServiceServer interface {
	mustEmbedUnimplementedPageServiceServer()
}

func RegisterPageServiceServer(s grpc.ServiceRegistrar, srv PageServiceServer) {
	// If the following call pancis, it indicates UnimplementedPageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PageService_ServiceDesc, srv)
}

func _PageService_GetAllPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetAllPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetAllPage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetAllPage(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByManyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManyNumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByManyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByManyId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByManyId(ctx, req.(*ManyNumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageBySlug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageBySlug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageBySlug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageBySlug(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByStatus(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByUser(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByType(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByTypeNStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByTypeNStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByTypeNStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByTypeNStatus(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByPublishYear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByPublishYear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByPublishYear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByPublishYear(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByPublishYearMonth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByPublishYearMonth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByPublishYearMonth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByPublishYearMonth(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_GetPageByPublishYearMonthDay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).GetPageByPublishYearMonthDay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_GetPageByPublishYearMonthDay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).GetPageByPublishYearMonthDay(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_CreateNewPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).CreateNewPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_CreateNewPage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).CreateNewPage(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_UpdatePage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).UpdatePage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_UpdatePage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).UpdatePage(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_DeletePage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).DeletePage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_DeletePage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).DeletePage(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_CountPageByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).CountPageByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_CountPageByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).CountPageByType(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PageService_CountPageByTypeNStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Page)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PageServiceServer).CountPageByTypeNStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PageService_CountPageByTypeNStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PageServiceServer).CountPageByTypeNStatus(ctx, req.(*Page))
	}
	return interceptor(ctx, in, info, handler)
}

// PageService_ServiceDesc is the grpc.ServiceDesc for PageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.PageService",
	HandlerType: (*PageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllPage",
			Handler:    _PageService_GetAllPage_Handler,
		},
		{
			MethodName: "GetPageById",
			Handler:    _PageService_GetPageById_Handler,
		},
		{
			MethodName: "GetPageByManyId",
			Handler:    _PageService_GetPageByManyId_Handler,
		},
		{
			MethodName: "GetPageBySlug",
			Handler:    _PageService_GetPageBySlug_Handler,
		},
		{
			MethodName: "GetPageByStatus",
			Handler:    _PageService_GetPageByStatus_Handler,
		},
		{
			MethodName: "GetPageByUser",
			Handler:    _PageService_GetPageByUser_Handler,
		},
		{
			MethodName: "GetPageByType",
			Handler:    _PageService_GetPageByType_Handler,
		},
		{
			MethodName: "GetPageByTypeNStatus",
			Handler:    _PageService_GetPageByTypeNStatus_Handler,
		},
		{
			MethodName: "GetPageByPublishYear",
			Handler:    _PageService_GetPageByPublishYear_Handler,
		},
		{
			MethodName: "GetPageByPublishYearMonth",
			Handler:    _PageService_GetPageByPublishYearMonth_Handler,
		},
		{
			MethodName: "GetPageByPublishYearMonthDay",
			Handler:    _PageService_GetPageByPublishYearMonthDay_Handler,
		},
		{
			MethodName: "CreateNewPage",
			Handler:    _PageService_CreateNewPage_Handler,
		},
		{
			MethodName: "UpdatePage",
			Handler:    _PageService_UpdatePage_Handler,
		},
		{
			MethodName: "DeletePage",
			Handler:    _PageService_DeletePage_Handler,
		},
		{
			MethodName: "CountPageByType",
			Handler:    _PageService_CountPageByType_Handler,
		},
		{
			MethodName: "CountPageByTypeNStatus",
			Handler:    _PageService_CountPageByTypeNStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	TagService_GetAllTag_FullMethodName      = "/pb.TagService/GetAllTag"
	TagService_GetTagById_FullMethodName     = "/pb.TagService/GetTagById"
	TagService_GetTagByManyId_FullMethodName = "/pb.TagService/GetTagByManyId"
	TagService_GetTagByType_FullMethodName   = "/pb.TagService/GetTagByType"
	TagService_GetTagBySlug_FullMethodName   = "/pb.TagService/GetTagBySlug"
	TagService_CreateNewTag_FullMethodName   = "/pb.TagService/CreateNewTag"
	TagService_UpdateTag_FullMethodName      = "/pb.TagService/UpdateTag"
	TagService_DeleteTag_FullMethodName      = "/pb.TagService/DeleteTag"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TagServiceClient interface {
	GetAllTag(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyTagResponse, error)
	GetTagById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*TagResponse, error)
	GetTagByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyTagResponse, error)
	GetTagByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyTagResponse, error)
	GetTagBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*TagResponse, error)
	CreateNewTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*TagResponse, error)
	UpdateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*MessageResponse, error)
	DeleteTag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetAllTag(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyTagResponse)
	err := c.cc.Invoke(ctx, TagService_GetAllTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagById(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*TagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, TagService_GetTagById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagByManyId(ctx context.Context, in *ManyNumbRequest, opts ...grpc.CallOption) (*ManyTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyTagResponse)
	err := c.cc.Invoke(ctx, TagService_GetTagByManyId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagByType(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyTagResponse)
	err := c.cc.Invoke(ctx, TagService_GetTagByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) GetTagBySlug(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*TagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, TagService_GetTagBySlug_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) CreateNewTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*TagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, TagService_CreateNewTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) UpdateTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, TagService_UpdateTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) DeleteTag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, TagService_DeleteTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility.
type TagServiceServer interface {
	GetAllTag(context.Context, *emptypb.Empty) (*ManyTagResponse, error)
	GetTagById(context.Context, *NumbRequest) (*TagResponse, error)
	GetTagByManyId(context.Context, *ManyNumbRequest) (*ManyTagResponse, error)
	GetTagByType(context.Context, *NumbRequest) (*ManyTagResponse, error)
	GetTagBySlug(context.Context, *MessageRequest) (*TagResponse, error)
	CreateNewTag(context.Context, *Tag) (*TagResponse, error)
	UpdateTag(context.Context, *Tag) (*MessageResponse, error)
	DeleteTag(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagServiceServer struct{}

func (UnimplementedTagServiceServer) GetAllTag(context.Context, *emptypb.Empty) (*ManyTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTag not implemented")
}
func (UnimplementedTagServiceServer) GetTagById(context.Context, *NumbRequest) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTagById not implemented")
}
func (UnimplementedTagServiceServer) GetTagByManyId(context.Context, *ManyNumbRequest) (*ManyTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTagByManyId not implemented")
}
func (UnimplementedTagServiceServer) GetTagByType(context.Context, *NumbRequest) (*ManyTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTagByType not implemented")
}
func (UnimplementedTagServiceServer) GetTagBySlug(context.Context, *MessageRequest) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTagBySlug not implemented")
}
func (UnimplementedTagServiceServer) CreateNewTag(context.Context, *Tag) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewTag not implemented")
}
func (UnimplementedTagServiceServer) UpdateTag(context.Context, *Tag) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTag not implemented")
}
func (UnimplementedTagServiceServer) DeleteTag(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTag not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}
func (UnimplementedTagServiceServer) testEmbeddedByValue()                    {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	// If the following call pancis, it indicates UnimplementedTagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_GetAllTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetAllTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetAllTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetAllTag(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagById(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagByManyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ManyNumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagByManyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagByManyId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagByManyId(ctx, req.(*ManyNumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagByType(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_GetTagBySlug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetTagBySlug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetTagBySlug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetTagBySlug(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_CreateNewTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).CreateNewTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_CreateNewTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).CreateNewTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_UpdateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).UpdateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_UpdateTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).UpdateTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_DeleteTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).DeleteTag(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllTag",
			Handler:    _TagService_GetAllTag_Handler,
		},
		{
			MethodName: "GetTagById",
			Handler:    _TagService_GetTagById_Handler,
		},
		{
			MethodName: "GetTagByManyId",
			Handler:    _TagService_GetTagByManyId_Handler,
		},
		{
			MethodName: "GetTagByType",
			Handler:    _TagService_GetTagByType_Handler,
		},
		{
			MethodName: "GetTagBySlug",
			Handler:    _TagService_GetTagBySlug_Handler,
		},
		{
			MethodName: "CreateNewTag",
			Handler:    _TagService_CreateNewTag_Handler,
		},
		{
			MethodName: "UpdateTag",
			Handler:    _TagService_UpdateTag_Handler,
		},
		{
			MethodName: "DeleteTag",
			Handler:    _TagService_DeleteTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	PagetagService_GetAllPagetag_FullMethodName    = "/pb.PagetagService/GetAllPagetag"
	PagetagService_GetPagetagByTag_FullMethodName  = "/pb.PagetagService/GetPagetagByTag"
	PagetagService_GetPagetagByPage_FullMethodName = "/pb.PagetagService/GetPagetagByPage"
	PagetagService_CreateNewPagetag_FullMethodName = "/pb.PagetagService/CreateNewPagetag"
	PagetagService_DeletePagetag_FullMethodName    = "/pb.PagetagService/DeletePagetag"
)

// PagetagServiceClient is the client API for PagetagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PagetagServiceClient interface {
	GetAllPagetag(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyPagetagResponse, error)
	GetPagetagByTag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagetagResponse, error)
	GetPagetagByPage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagetagResponse, error)
	CreateNewPagetag(ctx context.Context, in *Pagetag, opts ...grpc.CallOption) (*PagetagResponse, error)
	DeletePagetag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type pagetagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPagetagServiceClient(cc grpc.ClientConnInterface) PagetagServiceClient {
	return &pagetagServiceClient{cc}
}

func (c *pagetagServiceClient) GetAllPagetag(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyPagetagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagetagResponse)
	err := c.cc.Invoke(ctx, PagetagService_GetAllPagetag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagetagServiceClient) GetPagetagByTag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagetagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagetagResponse)
	err := c.cc.Invoke(ctx, PagetagService_GetPagetagByTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagetagServiceClient) GetPagetagByPage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagetagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagetagResponse)
	err := c.cc.Invoke(ctx, PagetagService_GetPagetagByPage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagetagServiceClient) CreateNewPagetag(ctx context.Context, in *Pagetag, opts ...grpc.CallOption) (*PagetagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PagetagResponse)
	err := c.cc.Invoke(ctx, PagetagService_CreateNewPagetag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagetagServiceClient) DeletePagetag(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, PagetagService_DeletePagetag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PagetagServiceServer is the server API for PagetagService service.
// All implementations must embed UnimplementedPagetagServiceServer
// for forward compatibility.
type PagetagServiceServer interface {
	GetAllPagetag(context.Context, *emptypb.Empty) (*ManyPagetagResponse, error)
	GetPagetagByTag(context.Context, *NumbRequest) (*ManyPagetagResponse, error)
	GetPagetagByPage(context.Context, *NumbRequest) (*ManyPagetagResponse, error)
	CreateNewPagetag(context.Context, *Pagetag) (*PagetagResponse, error)
	DeletePagetag(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedPagetagServiceServer()
}

// UnimplementedPagetagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPagetagServiceServer struct{}

func (UnimplementedPagetagServiceServer) GetAllPagetag(context.Context, *emptypb.Empty) (*ManyPagetagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPagetag not implemented")
}
func (UnimplementedPagetagServiceServer) GetPagetagByTag(context.Context, *NumbRequest) (*ManyPagetagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPagetagByTag not implemented")
}
func (UnimplementedPagetagServiceServer) GetPagetagByPage(context.Context, *NumbRequest) (*ManyPagetagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPagetagByPage not implemented")
}
func (UnimplementedPagetagServiceServer) CreateNewPagetag(context.Context, *Pagetag) (*PagetagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewPagetag not implemented")
}
func (UnimplementedPagetagServiceServer) DeletePagetag(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePagetag not implemented")
}
func (UnimplementedPagetagServiceServer) mustEmbedUnimplementedPagetagServiceServer() {}
func (UnimplementedPagetagServiceServer) testEmbeddedByValue()                        {}

// UnsafePagetagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PagetagServiceServer will
// result in compilation errors.
type UnsafePagetagServiceServer interface {
	mustEmbedUnimplementedPagetagServiceServer()
}

func RegisterPagetagServiceServer(s grpc.ServiceRegistrar, srv PagetagServiceServer) {
	// If the following call pancis, it indicates UnimplementedPagetagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PagetagService_ServiceDesc, srv)
}

func _PagetagService_GetAllPagetag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagetagServiceServer).GetAllPagetag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagetagService_GetAllPagetag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagetagServiceServer).GetAllPagetag(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagetagService_GetPagetagByTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagetagServiceServer).GetPagetagByTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagetagService_GetPagetagByTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagetagServiceServer).GetPagetagByTag(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagetagService_GetPagetagByPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagetagServiceServer).GetPagetagByPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagetagService_GetPagetagByPage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagetagServiceServer).GetPagetagByPage(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagetagService_CreateNewPagetag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagetag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagetagServiceServer).CreateNewPagetag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagetagService_CreateNewPagetag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagetagServiceServer).CreateNewPagetag(ctx, req.(*Pagetag))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagetagService_DeletePagetag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagetagServiceServer).DeletePagetag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagetagService_DeletePagetag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagetagServiceServer).DeletePagetag(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PagetagService_ServiceDesc is the grpc.ServiceDesc for PagetagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PagetagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.PagetagService",
	HandlerType: (*PagetagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllPagetag",
			Handler:    _PagetagService_GetAllPagetag_Handler,
		},
		{
			MethodName: "GetPagetagByTag",
			Handler:    _PagetagService_GetPagetagByTag_Handler,
		},
		{
			MethodName: "GetPagetagByPage",
			Handler:    _PagetagService_GetPagetagByPage_Handler,
		},
		{
			MethodName: "CreateNewPagetag",
			Handler:    _PagetagService_CreateNewPagetag_Handler,
		},
		{
			MethodName: "DeletePagetag",
			Handler:    _PagetagService_DeletePagetag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}

const (
	PagecategoryService_GetAllPagecategory_FullMethodName        = "/pb.PagecategoryService/GetAllPagecategory"
	PagecategoryService_GetPagecategoryByCategory_FullMethodName = "/pb.PagecategoryService/GetPagecategoryByCategory"
	PagecategoryService_GetPagecategoryByPage_FullMethodName     = "/pb.PagecategoryService/GetPagecategoryByPage"
	PagecategoryService_CreateNewPagecategory_FullMethodName     = "/pb.PagecategoryService/CreateNewPagecategory"
	PagecategoryService_DeletePagecategory_FullMethodName        = "/pb.PagecategoryService/DeletePagecategory"
)

// PagecategoryServiceClient is the client API for PagecategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PagecategoryServiceClient interface {
	GetAllPagecategory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error)
	GetPagecategoryByCategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error)
	GetPagecategoryByPage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error)
	CreateNewPagecategory(ctx context.Context, in *Pagecategory, opts ...grpc.CallOption) (*PagecategoryResponse, error)
	DeletePagecategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type pagecategoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPagecategoryServiceClient(cc grpc.ClientConnInterface) PagecategoryServiceClient {
	return &pagecategoryServiceClient{cc}
}

func (c *pagecategoryServiceClient) GetAllPagecategory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagecategoryResponse)
	err := c.cc.Invoke(ctx, PagecategoryService_GetAllPagecategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagecategoryServiceClient) GetPagecategoryByCategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagecategoryResponse)
	err := c.cc.Invoke(ctx, PagecategoryService_GetPagecategoryByCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagecategoryServiceClient) GetPagecategoryByPage(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*ManyPagecategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ManyPagecategoryResponse)
	err := c.cc.Invoke(ctx, PagecategoryService_GetPagecategoryByPage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagecategoryServiceClient) CreateNewPagecategory(ctx context.Context, in *Pagecategory, opts ...grpc.CallOption) (*PagecategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PagecategoryResponse)
	err := c.cc.Invoke(ctx, PagecategoryService_CreateNewPagecategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pagecategoryServiceClient) DeletePagecategory(ctx context.Context, in *NumbRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, PagecategoryService_DeletePagecategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PagecategoryServiceServer is the server API for PagecategoryService service.
// All implementations must embed UnimplementedPagecategoryServiceServer
// for forward compatibility.
type PagecategoryServiceServer interface {
	GetAllPagecategory(context.Context, *emptypb.Empty) (*ManyPagecategoryResponse, error)
	GetPagecategoryByCategory(context.Context, *NumbRequest) (*ManyPagecategoryResponse, error)
	GetPagecategoryByPage(context.Context, *NumbRequest) (*ManyPagecategoryResponse, error)
	CreateNewPagecategory(context.Context, *Pagecategory) (*PagecategoryResponse, error)
	DeletePagecategory(context.Context, *NumbRequest) (*MessageResponse, error)
	mustEmbedUnimplementedPagecategoryServiceServer()
}

// UnimplementedPagecategoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPagecategoryServiceServer struct{}

func (UnimplementedPagecategoryServiceServer) GetAllPagecategory(context.Context, *emptypb.Empty) (*ManyPagecategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPagecategory not implemented")
}
func (UnimplementedPagecategoryServiceServer) GetPagecategoryByCategory(context.Context, *NumbRequest) (*ManyPagecategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPagecategoryByCategory not implemented")
}
func (UnimplementedPagecategoryServiceServer) GetPagecategoryByPage(context.Context, *NumbRequest) (*ManyPagecategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPagecategoryByPage not implemented")
}
func (UnimplementedPagecategoryServiceServer) CreateNewPagecategory(context.Context, *Pagecategory) (*PagecategoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewPagecategory not implemented")
}
func (UnimplementedPagecategoryServiceServer) DeletePagecategory(context.Context, *NumbRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePagecategory not implemented")
}
func (UnimplementedPagecategoryServiceServer) mustEmbedUnimplementedPagecategoryServiceServer() {}
func (UnimplementedPagecategoryServiceServer) testEmbeddedByValue()                             {}

// UnsafePagecategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PagecategoryServiceServer will
// result in compilation errors.
type UnsafePagecategoryServiceServer interface {
	mustEmbedUnimplementedPagecategoryServiceServer()
}

func RegisterPagecategoryServiceServer(s grpc.ServiceRegistrar, srv PagecategoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedPagecategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PagecategoryService_ServiceDesc, srv)
}

func _PagecategoryService_GetAllPagecategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagecategoryServiceServer).GetAllPagecategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagecategoryService_GetAllPagecategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagecategoryServiceServer).GetAllPagecategory(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagecategoryService_GetPagecategoryByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagecategoryServiceServer).GetPagecategoryByCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagecategoryService_GetPagecategoryByCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagecategoryServiceServer).GetPagecategoryByCategory(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagecategoryService_GetPagecategoryByPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagecategoryServiceServer).GetPagecategoryByPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagecategoryService_GetPagecategoryByPage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagecategoryServiceServer).GetPagecategoryByPage(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagecategoryService_CreateNewPagecategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pagecategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagecategoryServiceServer).CreateNewPagecategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagecategoryService_CreateNewPagecategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagecategoryServiceServer).CreateNewPagecategory(ctx, req.(*Pagecategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _PagecategoryService_DeletePagecategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PagecategoryServiceServer).DeletePagecategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PagecategoryService_DeletePagecategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PagecategoryServiceServer).DeletePagecategory(ctx, req.(*NumbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PagecategoryService_ServiceDesc is the grpc.ServiceDesc for PagecategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PagecategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.PagecategoryService",
	HandlerType: (*PagecategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllPagecategory",
			Handler:    _PagecategoryService_GetAllPagecategory_Handler,
		},
		{
			MethodName: "GetPagecategoryByCategory",
			Handler:    _PagecategoryService_GetPagecategoryByCategory_Handler,
		},
		{
			MethodName: "GetPagecategoryByPage",
			Handler:    _PagecategoryService_GetPagecategoryByPage_Handler,
		},
		{
			MethodName: "CreateNewPagecategory",
			Handler:    _PagecategoryService_CreateNewPagecategory_Handler,
		},
		{
			MethodName: "DeletePagecategory",
			Handler:    _PagecategoryService_DeletePagecategory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/main.proto",
}
